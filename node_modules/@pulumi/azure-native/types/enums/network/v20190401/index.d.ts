export declare const Access: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The access type of the rule.
 */
export declare type Access = (typeof Access)[keyof typeof Access];
export declare const ApplicationGatewayCookieBasedAffinity: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Cookie based affinity.
 */
export declare type ApplicationGatewayCookieBasedAffinity = (typeof ApplicationGatewayCookieBasedAffinity)[keyof typeof ApplicationGatewayCookieBasedAffinity];
export declare const ApplicationGatewayCustomErrorStatusCode: {
    readonly HttpStatus403: "HttpStatus403";
    readonly HttpStatus502: "HttpStatus502";
};
/**
 * Status code of the application gateway customer error.
 */
export declare type ApplicationGatewayCustomErrorStatusCode = (typeof ApplicationGatewayCustomErrorStatusCode)[keyof typeof ApplicationGatewayCustomErrorStatusCode];
export declare const ApplicationGatewayFirewallMode: {
    readonly Detection: "Detection";
    readonly Prevention: "Prevention";
};
/**
 * Web application firewall mode.
 */
export declare type ApplicationGatewayFirewallMode = (typeof ApplicationGatewayFirewallMode)[keyof typeof ApplicationGatewayFirewallMode];
export declare const ApplicationGatewayProtocol: {
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * The protocol used for the probe.
 */
export declare type ApplicationGatewayProtocol = (typeof ApplicationGatewayProtocol)[keyof typeof ApplicationGatewayProtocol];
export declare const ApplicationGatewayRedirectType: {
    readonly Permanent: "Permanent";
    readonly Found: "Found";
    readonly SeeOther: "SeeOther";
    readonly Temporary: "Temporary";
};
/**
 * HTTP redirection type.
 */
export declare type ApplicationGatewayRedirectType = (typeof ApplicationGatewayRedirectType)[keyof typeof ApplicationGatewayRedirectType];
export declare const ApplicationGatewayRequestRoutingRuleType: {
    readonly Basic: "Basic";
    readonly PathBasedRouting: "PathBasedRouting";
};
/**
 * Rule type.
 */
export declare type ApplicationGatewayRequestRoutingRuleType = (typeof ApplicationGatewayRequestRoutingRuleType)[keyof typeof ApplicationGatewayRequestRoutingRuleType];
export declare const ApplicationGatewaySkuName: {
    readonly Standard_Small: "Standard_Small";
    readonly Standard_Medium: "Standard_Medium";
    readonly Standard_Large: "Standard_Large";
    readonly WAF_Medium: "WAF_Medium";
    readonly WAF_Large: "WAF_Large";
    readonly Standard_v2: "Standard_v2";
    readonly WAF_v2: "WAF_v2";
};
/**
 * Name of an application gateway SKU.
 */
export declare type ApplicationGatewaySkuName = (typeof ApplicationGatewaySkuName)[keyof typeof ApplicationGatewaySkuName];
export declare const ApplicationGatewaySslCipherSuite: {
    readonly TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384";
    readonly TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256";
    readonly TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA";
    readonly TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA";
    readonly TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384";
    readonly TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_DHE_RSA_WITH_AES_256_CBC_SHA: "TLS_DHE_RSA_WITH_AES_256_CBC_SHA";
    readonly TLS_DHE_RSA_WITH_AES_128_CBC_SHA: "TLS_DHE_RSA_WITH_AES_128_CBC_SHA";
    readonly TLS_RSA_WITH_AES_256_GCM_SHA384: "TLS_RSA_WITH_AES_256_GCM_SHA384";
    readonly TLS_RSA_WITH_AES_128_GCM_SHA256: "TLS_RSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_RSA_WITH_AES_256_CBC_SHA256: "TLS_RSA_WITH_AES_256_CBC_SHA256";
    readonly TLS_RSA_WITH_AES_128_CBC_SHA256: "TLS_RSA_WITH_AES_128_CBC_SHA256";
    readonly TLS_RSA_WITH_AES_256_CBC_SHA: "TLS_RSA_WITH_AES_256_CBC_SHA";
    readonly TLS_RSA_WITH_AES_128_CBC_SHA: "TLS_RSA_WITH_AES_128_CBC_SHA";
    readonly TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384";
    readonly TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384";
    readonly TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256";
    readonly TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA";
    readonly TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA";
    readonly TLS_DHE_DSS_WITH_AES_256_CBC_SHA256: "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256";
    readonly TLS_DHE_DSS_WITH_AES_128_CBC_SHA256: "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256";
    readonly TLS_DHE_DSS_WITH_AES_256_CBC_SHA: "TLS_DHE_DSS_WITH_AES_256_CBC_SHA";
    readonly TLS_DHE_DSS_WITH_AES_128_CBC_SHA: "TLS_DHE_DSS_WITH_AES_128_CBC_SHA";
    readonly TLS_RSA_WITH_3DES_EDE_CBC_SHA: "TLS_RSA_WITH_3DES_EDE_CBC_SHA";
    readonly TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA: "TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA";
    readonly TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256";
    readonly TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384";
};
/**
 * Ssl cipher suites enums.
 */
export declare type ApplicationGatewaySslCipherSuite = (typeof ApplicationGatewaySslCipherSuite)[keyof typeof ApplicationGatewaySslCipherSuite];
export declare const ApplicationGatewaySslPolicyName: {
    readonly AppGwSslPolicy20150501: "AppGwSslPolicy20150501";
    readonly AppGwSslPolicy20170401: "AppGwSslPolicy20170401";
    readonly AppGwSslPolicy20170401S: "AppGwSslPolicy20170401S";
};
/**
 * Name of Ssl predefined policy.
 */
export declare type ApplicationGatewaySslPolicyName = (typeof ApplicationGatewaySslPolicyName)[keyof typeof ApplicationGatewaySslPolicyName];
export declare const ApplicationGatewaySslPolicyType: {
    readonly Predefined: "Predefined";
    readonly Custom: "Custom";
};
/**
 * Type of Ssl Policy.
 */
export declare type ApplicationGatewaySslPolicyType = (typeof ApplicationGatewaySslPolicyType)[keyof typeof ApplicationGatewaySslPolicyType];
export declare const ApplicationGatewaySslProtocol: {
    readonly TLSv1_0: "TLSv1_0";
    readonly TLSv1_1: "TLSv1_1";
    readonly TLSv1_2: "TLSv1_2";
};
/**
 * Minimum version of Ssl protocol to be supported on application gateway.
 */
export declare type ApplicationGatewaySslProtocol = (typeof ApplicationGatewaySslProtocol)[keyof typeof ApplicationGatewaySslProtocol];
export declare const ApplicationGatewayTier: {
    readonly Standard: "Standard";
    readonly WAF: "WAF";
    readonly Standard_v2: "Standard_v2";
    readonly WAF_v2: "WAF_v2";
};
/**
 * Tier of an application gateway.
 */
export declare type ApplicationGatewayTier = (typeof ApplicationGatewayTier)[keyof typeof ApplicationGatewayTier];
export declare const AuthorizationUseStatus: {
    readonly Available: "Available";
    readonly InUse: "InUse";
};
/**
 * The authorization use status.
 */
export declare type AuthorizationUseStatus = (typeof AuthorizationUseStatus)[keyof typeof AuthorizationUseStatus];
export declare const AzureFirewallApplicationRuleProtocolType: {
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Protocol type.
 */
export declare type AzureFirewallApplicationRuleProtocolType = (typeof AzureFirewallApplicationRuleProtocolType)[keyof typeof AzureFirewallApplicationRuleProtocolType];
export declare const AzureFirewallNatRCActionType: {
    readonly Snat: "Snat";
    readonly Dnat: "Dnat";
};
/**
 * The type of action.
 */
export declare type AzureFirewallNatRCActionType = (typeof AzureFirewallNatRCActionType)[keyof typeof AzureFirewallNatRCActionType];
export declare const AzureFirewallNetworkRuleProtocol: {
    readonly TCP: "TCP";
    readonly UDP: "UDP";
    readonly Any: "Any";
    readonly ICMP: "ICMP";
};
/**
 * The protocol of a Network Rule resource.
 */
export declare type AzureFirewallNetworkRuleProtocol = (typeof AzureFirewallNetworkRuleProtocol)[keyof typeof AzureFirewallNetworkRuleProtocol];
export declare const AzureFirewallRCActionType: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The type of action.
 */
export declare type AzureFirewallRCActionType = (typeof AzureFirewallRCActionType)[keyof typeof AzureFirewallRCActionType];
export declare const AzureFirewallThreatIntelMode: {
    readonly Alert: "Alert";
    readonly Deny: "Deny";
    readonly Off: "Off";
};
/**
 * The operation mode for Threat Intelligence.
 */
export declare type AzureFirewallThreatIntelMode = (typeof AzureFirewallThreatIntelMode)[keyof typeof AzureFirewallThreatIntelMode];
export declare const BackendEnabledState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
 */
export declare type BackendEnabledState = (typeof BackendEnabledState)[keyof typeof BackendEnabledState];
export declare const DdosCustomPolicyProtocol: {
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly Syn: "Syn";
};
/**
 * The protocol for which the DDoS protection policy is being customized.
 */
export declare type DdosCustomPolicyProtocol = (typeof DdosCustomPolicyProtocol)[keyof typeof DdosCustomPolicyProtocol];
export declare const DdosCustomPolicyTriggerSensitivityOverride: {
    readonly Relaxed: "Relaxed";
    readonly Low: "Low";
    readonly Default: "Default";
    readonly High: "High";
};
/**
 * The customized DDoS protection trigger rate sensitivity degrees. High: Trigger rate set with most sensitivity w.r.t. normal traffic. Default: Trigger rate set with moderate sensitivity w.r.t. normal traffic. Low: Trigger rate set with less sensitivity w.r.t. normal traffic. Relaxed: Trigger rate set with least sensitivity w.r.t. normal traffic.
 */
export declare type DdosCustomPolicyTriggerSensitivityOverride = (typeof DdosCustomPolicyTriggerSensitivityOverride)[keyof typeof DdosCustomPolicyTriggerSensitivityOverride];
export declare const DdosSettingsProtectionCoverage: {
    readonly Basic: "Basic";
    readonly Standard: "Standard";
};
/**
 * The DDoS protection policy customizability of the public IP. Only standard coverage will have the ability to be customized.
 */
export declare type DdosSettingsProtectionCoverage = (typeof DdosSettingsProtectionCoverage)[keyof typeof DdosSettingsProtectionCoverage];
export declare const DhGroup: {
    readonly None: "None";
    readonly DHGroup1: "DHGroup1";
    readonly DHGroup2: "DHGroup2";
    readonly DHGroup14: "DHGroup14";
    readonly DHGroup2048: "DHGroup2048";
    readonly ECP256: "ECP256";
    readonly ECP384: "ECP384";
    readonly DHGroup24: "DHGroup24";
};
/**
 * The DH Group used in IKE Phase 1 for initial SA.
 */
export declare type DhGroup = (typeof DhGroup)[keyof typeof DhGroup];
export declare const DynamicCompressionEnabled: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to use dynamic compression for cached content
 */
export declare type DynamicCompressionEnabled = (typeof DynamicCompressionEnabled)[keyof typeof DynamicCompressionEnabled];
export declare const EnforceCertificateNameCheckEnabledState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
 */
export declare type EnforceCertificateNameCheckEnabledState = (typeof EnforceCertificateNameCheckEnabledState)[keyof typeof EnforceCertificateNameCheckEnabledState];
export declare const ExpressRouteCircuitPeeringAdvertisedPublicPrefixState: {
    readonly NotConfigured: "NotConfigured";
    readonly Configuring: "Configuring";
    readonly Configured: "Configured";
    readonly ValidationNeeded: "ValidationNeeded";
};
/**
 * The advertised public prefix state of the Peering resource.
 */
export declare type ExpressRouteCircuitPeeringAdvertisedPublicPrefixState = (typeof ExpressRouteCircuitPeeringAdvertisedPublicPrefixState)[keyof typeof ExpressRouteCircuitPeeringAdvertisedPublicPrefixState];
export declare const ExpressRouteCircuitPeeringState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * The state of peering.
 */
export declare type ExpressRouteCircuitPeeringState = (typeof ExpressRouteCircuitPeeringState)[keyof typeof ExpressRouteCircuitPeeringState];
export declare const ExpressRouteCircuitSkuFamily: {
    readonly UnlimitedData: "UnlimitedData";
    readonly MeteredData: "MeteredData";
};
/**
 * The family of the SKU.
 */
export declare type ExpressRouteCircuitSkuFamily = (typeof ExpressRouteCircuitSkuFamily)[keyof typeof ExpressRouteCircuitSkuFamily];
export declare const ExpressRouteCircuitSkuTier: {
    readonly Standard: "Standard";
    readonly Premium: "Premium";
    readonly Basic: "Basic";
    readonly Local: "Local";
};
/**
 * The tier of the SKU.
 */
export declare type ExpressRouteCircuitSkuTier = (typeof ExpressRouteCircuitSkuTier)[keyof typeof ExpressRouteCircuitSkuTier];
export declare const ExpressRouteLinkAdminState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Administrative state of the physical port.
 */
export declare type ExpressRouteLinkAdminState = (typeof ExpressRouteLinkAdminState)[keyof typeof ExpressRouteLinkAdminState];
export declare const ExpressRoutePeeringState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * The peering state.
 */
export declare type ExpressRoutePeeringState = (typeof ExpressRoutePeeringState)[keyof typeof ExpressRoutePeeringState];
export declare const ExpressRoutePeeringType: {
    readonly AzurePublicPeering: "AzurePublicPeering";
    readonly AzurePrivatePeering: "AzurePrivatePeering";
    readonly MicrosoftPeering: "MicrosoftPeering";
};
/**
 * The peering type.
 */
export declare type ExpressRoutePeeringType = (typeof ExpressRoutePeeringType)[keyof typeof ExpressRoutePeeringType];
export declare const ExpressRoutePortsEncapsulation: {
    readonly Dot1Q: "Dot1Q";
    readonly QinQ: "QinQ";
};
/**
 * Encapsulation method on physical ports.
 */
export declare type ExpressRoutePortsEncapsulation = (typeof ExpressRoutePortsEncapsulation)[keyof typeof ExpressRoutePortsEncapsulation];
export declare const FrontDoorEnabledState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Operational status of the Front Door load balancer. Permitted values are 'Enabled' or 'Disabled'
 */
export declare type FrontDoorEnabledState = (typeof FrontDoorEnabledState)[keyof typeof FrontDoorEnabledState];
export declare const FrontDoorForwardingProtocol: {
    readonly HttpOnly: "HttpOnly";
    readonly HttpsOnly: "HttpsOnly";
    readonly MatchRequest: "MatchRequest";
};
/**
 * Protocol this rule will use when forwarding traffic to backends.
 */
export declare type FrontDoorForwardingProtocol = (typeof FrontDoorForwardingProtocol)[keyof typeof FrontDoorForwardingProtocol];
export declare const FrontDoorProtocol: {
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Accepted protocol schemes.
 */
export declare type FrontDoorProtocol = (typeof FrontDoorProtocol)[keyof typeof FrontDoorProtocol];
export declare const FrontDoorQuery: {
    readonly StripNone: "StripNone";
    readonly StripAll: "StripAll";
};
/**
 * Treatment of URL query terms when forming the cache key.
 */
export declare type FrontDoorQuery = (typeof FrontDoorQuery)[keyof typeof FrontDoorQuery];
export declare const FrontDoorRedirectProtocol: {
    readonly HttpOnly: "HttpOnly";
    readonly HttpsOnly: "HttpsOnly";
    readonly MatchRequest: "MatchRequest";
};
/**
 * The protocol of the destination to where the traffic is redirected
 */
export declare type FrontDoorRedirectProtocol = (typeof FrontDoorRedirectProtocol)[keyof typeof FrontDoorRedirectProtocol];
export declare const FrontDoorRedirectType: {
    readonly Moved: "Moved";
    readonly Found: "Found";
    readonly TemporaryRedirect: "TemporaryRedirect";
    readonly PermanentRedirect: "PermanentRedirect";
};
/**
 * The redirect type the rule will use when redirecting traffic.
 */
export declare type FrontDoorRedirectType = (typeof FrontDoorRedirectType)[keyof typeof FrontDoorRedirectType];
export declare const IPAllocationMethod: {
    readonly Static: "Static";
    readonly Dynamic: "Dynamic";
};
/**
 * The private IP address allocation method.
 */
export declare type IPAllocationMethod = (typeof IPAllocationMethod)[keyof typeof IPAllocationMethod];
export declare const IPVersion: {
    readonly IPv4: "IPv4";
    readonly IPv6: "IPv6";
};
/**
 * Available from Api-Version 2016-03-30 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.
 */
export declare type IPVersion = (typeof IPVersion)[keyof typeof IPVersion];
export declare const IkeEncryption: {
    readonly DES: "DES";
    readonly DES3: "DES3";
    readonly AES128: "AES128";
    readonly AES192: "AES192";
    readonly AES256: "AES256";
    readonly GCMAES256: "GCMAES256";
    readonly GCMAES128: "GCMAES128";
};
/**
 * The IKE encryption algorithm (IKE phase 2).
 */
export declare type IkeEncryption = (typeof IkeEncryption)[keyof typeof IkeEncryption];
export declare const IkeIntegrity: {
    readonly MD5: "MD5";
    readonly SHA1: "SHA1";
    readonly SHA256: "SHA256";
    readonly SHA384: "SHA384";
    readonly GCMAES256: "GCMAES256";
    readonly GCMAES128: "GCMAES128";
};
/**
 * The IKE integrity algorithm (IKE phase 2).
 */
export declare type IkeIntegrity = (typeof IkeIntegrity)[keyof typeof IkeIntegrity];
export declare const IpsecEncryption: {
    readonly None: "None";
    readonly DES: "DES";
    readonly DES3: "DES3";
    readonly AES128: "AES128";
    readonly AES192: "AES192";
    readonly AES256: "AES256";
    readonly GCMAES128: "GCMAES128";
    readonly GCMAES192: "GCMAES192";
    readonly GCMAES256: "GCMAES256";
};
/**
 * The IPSec encryption algorithm (IKE phase 1).
 */
export declare type IpsecEncryption = (typeof IpsecEncryption)[keyof typeof IpsecEncryption];
export declare const IpsecIntegrity: {
    readonly MD5: "MD5";
    readonly SHA1: "SHA1";
    readonly SHA256: "SHA256";
    readonly GCMAES128: "GCMAES128";
    readonly GCMAES192: "GCMAES192";
    readonly GCMAES256: "GCMAES256";
};
/**
 * The IPSec integrity algorithm (IKE phase 1).
 */
export declare type IpsecIntegrity = (typeof IpsecIntegrity)[keyof typeof IpsecIntegrity];
export declare const LoadBalancerOutboundRuleProtocol: {
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly All: "All";
};
/**
 * The protocol for the outbound rule in load balancer.
 */
export declare type LoadBalancerOutboundRuleProtocol = (typeof LoadBalancerOutboundRuleProtocol)[keyof typeof LoadBalancerOutboundRuleProtocol];
export declare const LoadBalancerSkuName: {
    readonly Basic: "Basic";
    readonly Standard: "Standard";
};
/**
 * Name of a load balancer SKU.
 */
export declare type LoadBalancerSkuName = (typeof LoadBalancerSkuName)[keyof typeof LoadBalancerSkuName];
export declare const LoadDistribution: {
    readonly Default: "Default";
    readonly SourceIP: "SourceIP";
    readonly SourceIPProtocol: "SourceIPProtocol";
};
/**
 * The load distribution policy for this rule.
 */
export declare type LoadDistribution = (typeof LoadDistribution)[keyof typeof LoadDistribution];
export declare const NatGatewaySkuName: {
    readonly Standard: "Standard";
};
/**
 * Name of Nat Gateway SKU.
 */
export declare type NatGatewaySkuName = (typeof NatGatewaySkuName)[keyof typeof NatGatewaySkuName];
export declare const PcProtocol: {
    readonly TCP: "TCP";
    readonly UDP: "UDP";
    readonly Any: "Any";
};
/**
 * Protocol to be filtered on.
 */
export declare type PcProtocol = (typeof PcProtocol)[keyof typeof PcProtocol];
export declare const PfsGroup: {
    readonly None: "None";
    readonly PFS1: "PFS1";
    readonly PFS2: "PFS2";
    readonly PFS2048: "PFS2048";
    readonly ECP256: "ECP256";
    readonly ECP384: "ECP384";
    readonly PFS24: "PFS24";
    readonly PFS14: "PFS14";
    readonly PFSMM: "PFSMM";
};
/**
 * The Pfs Group used in IKE Phase 2 for new child SA.
 */
export declare type PfsGroup = (typeof PfsGroup)[keyof typeof PfsGroup];
export declare const ProbeProtocol: {
    readonly Http: "Http";
    readonly Tcp: "Tcp";
    readonly Https: "Https";
};
/**
 * The protocol of the end point. If 'Tcp' is specified, a received ACK is required for the probe to be successful. If 'Http' or 'Https' is specified, a 200 OK response from the specifies URI is required for the probe to be successful.
 */
export declare type ProbeProtocol = (typeof ProbeProtocol)[keyof typeof ProbeProtocol];
export declare const PublicIPAddressSkuName: {
    readonly Basic: "Basic";
    readonly Standard: "Standard";
};
/**
 * Name of a public IP address SKU.
 */
export declare type PublicIPAddressSkuName = (typeof PublicIPAddressSkuName)[keyof typeof PublicIPAddressSkuName];
export declare const PublicIPPrefixSkuName: {
    readonly Standard: "Standard";
};
/**
 * Name of a public IP prefix SKU.
 */
export declare type PublicIPPrefixSkuName = (typeof PublicIPPrefixSkuName)[keyof typeof PublicIPPrefixSkuName];
export declare const ResourceIdentityType: {
    readonly SystemAssigned: "SystemAssigned";
    readonly UserAssigned: "UserAssigned";
    readonly SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned";
    readonly None: "None";
};
/**
 * The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
 */
export declare type ResourceIdentityType = (typeof ResourceIdentityType)[keyof typeof ResourceIdentityType];
export declare const RouteFilterRuleType: {
    readonly Community: "Community";
};
/**
 * The rule type of the rule.
 */
export declare type RouteFilterRuleType = (typeof RouteFilterRuleType)[keyof typeof RouteFilterRuleType];
export declare const RouteNextHopType: {
    readonly VirtualNetworkGateway: "VirtualNetworkGateway";
    readonly VnetLocal: "VnetLocal";
    readonly Internet: "Internet";
    readonly VirtualAppliance: "VirtualAppliance";
    readonly None: "None";
};
/**
 * The type of Azure hop the packet should be sent to.
 */
export declare type RouteNextHopType = (typeof RouteNextHopType)[keyof typeof RouteNextHopType];
export declare const RoutingRuleEnabledState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
 */
export declare type RoutingRuleEnabledState = (typeof RoutingRuleEnabledState)[keyof typeof RoutingRuleEnabledState];
export declare const SecurityRuleAccess: {
    readonly Allow: "Allow";
    readonly Deny: "Deny";
};
/**
 * The network traffic is allowed or denied.
 */
export declare type SecurityRuleAccess = (typeof SecurityRuleAccess)[keyof typeof SecurityRuleAccess];
export declare const SecurityRuleDirection: {
    readonly Inbound: "Inbound";
    readonly Outbound: "Outbound";
};
/**
 * The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic.
 */
export declare type SecurityRuleDirection = (typeof SecurityRuleDirection)[keyof typeof SecurityRuleDirection];
export declare const SecurityRuleProtocol: {
    readonly Tcp: "Tcp";
    readonly Udp: "Udp";
    readonly Icmp: "Icmp";
    readonly Esp: "Esp";
    readonly Asterisk: "*";
};
/**
 * Network protocol this rule applies to.
 */
export declare type SecurityRuleProtocol = (typeof SecurityRuleProtocol)[keyof typeof SecurityRuleProtocol];
export declare const ServiceProviderProvisioningState: {
    readonly NotProvisioned: "NotProvisioned";
    readonly Provisioning: "Provisioning";
    readonly Provisioned: "Provisioned";
    readonly Deprovisioning: "Deprovisioning";
};
/**
 * The ServiceProviderProvisioningState state of the resource.
 */
export declare type ServiceProviderProvisioningState = (typeof ServiceProviderProvisioningState)[keyof typeof ServiceProviderProvisioningState];
export declare const SessionAffinityEnabledState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
 */
export declare type SessionAffinityEnabledState = (typeof SessionAffinityEnabledState)[keyof typeof SessionAffinityEnabledState];
export declare const TransportProtocol: {
    readonly Udp: "Udp";
    readonly Tcp: "Tcp";
    readonly All: "All";
};
/**
 * The reference to the transport protocol used by the load balancing rule.
 */
export declare type TransportProtocol = (typeof TransportProtocol)[keyof typeof TransportProtocol];
export declare const VirtualNetworkGatewayConnectionProtocol: {
    readonly IKEv2: "IKEv2";
    readonly IKEv1: "IKEv1";
};
/**
 * Connection protocol used for this connection.
 */
export declare type VirtualNetworkGatewayConnectionProtocol = (typeof VirtualNetworkGatewayConnectionProtocol)[keyof typeof VirtualNetworkGatewayConnectionProtocol];
export declare const VirtualNetworkGatewayConnectionType: {
    readonly IPsec: "IPsec";
    readonly Vnet2Vnet: "Vnet2Vnet";
    readonly ExpressRoute: "ExpressRoute";
    readonly VPNClient: "VPNClient";
};
/**
 * Gateway connection type.
 */
export declare type VirtualNetworkGatewayConnectionType = (typeof VirtualNetworkGatewayConnectionType)[keyof typeof VirtualNetworkGatewayConnectionType];
export declare const VirtualNetworkGatewaySkuName: {
    readonly Basic: "Basic";
    readonly HighPerformance: "HighPerformance";
    readonly Standard: "Standard";
    readonly UltraPerformance: "UltraPerformance";
    readonly VpnGw1: "VpnGw1";
    readonly VpnGw2: "VpnGw2";
    readonly VpnGw3: "VpnGw3";
    readonly VpnGw1AZ: "VpnGw1AZ";
    readonly VpnGw2AZ: "VpnGw2AZ";
    readonly VpnGw3AZ: "VpnGw3AZ";
    readonly ErGw1AZ: "ErGw1AZ";
    readonly ErGw2AZ: "ErGw2AZ";
    readonly ErGw3AZ: "ErGw3AZ";
};
/**
 * Gateway SKU name.
 */
export declare type VirtualNetworkGatewaySkuName = (typeof VirtualNetworkGatewaySkuName)[keyof typeof VirtualNetworkGatewaySkuName];
export declare const VirtualNetworkGatewaySkuTier: {
    readonly Basic: "Basic";
    readonly HighPerformance: "HighPerformance";
    readonly Standard: "Standard";
    readonly UltraPerformance: "UltraPerformance";
    readonly VpnGw1: "VpnGw1";
    readonly VpnGw2: "VpnGw2";
    readonly VpnGw3: "VpnGw3";
    readonly VpnGw1AZ: "VpnGw1AZ";
    readonly VpnGw2AZ: "VpnGw2AZ";
    readonly VpnGw3AZ: "VpnGw3AZ";
    readonly ErGw1AZ: "ErGw1AZ";
    readonly ErGw2AZ: "ErGw2AZ";
    readonly ErGw3AZ: "ErGw3AZ";
};
/**
 * Gateway SKU tier.
 */
export declare type VirtualNetworkGatewaySkuTier = (typeof VirtualNetworkGatewaySkuTier)[keyof typeof VirtualNetworkGatewaySkuTier];
export declare const VirtualNetworkGatewayType: {
    readonly Vpn: "Vpn";
    readonly ExpressRoute: "ExpressRoute";
};
/**
 * The type of this virtual network gateway.
 */
export declare type VirtualNetworkGatewayType = (typeof VirtualNetworkGatewayType)[keyof typeof VirtualNetworkGatewayType];
export declare const VirtualNetworkPeeringState: {
    readonly Initiated: "Initiated";
    readonly Connected: "Connected";
    readonly Disconnected: "Disconnected";
};
/**
 * The status of the virtual network peering.
 */
export declare type VirtualNetworkPeeringState = (typeof VirtualNetworkPeeringState)[keyof typeof VirtualNetworkPeeringState];
export declare const VpnClientProtocol: {
    readonly IkeV2: "IkeV2";
    readonly SSTP: "SSTP";
    readonly OpenVPN: "OpenVPN";
};
/**
 * VPN client protocol enabled for the virtual network gateway.
 */
export declare type VpnClientProtocol = (typeof VpnClientProtocol)[keyof typeof VpnClientProtocol];
export declare const VpnGatewayTunnelingProtocol: {
    readonly IkeV2: "IkeV2";
    readonly OpenVPN: "OpenVPN";
};
/**
 * VPN protocol enabled for the P2SVpnServerConfiguration.
 */
export declare type VpnGatewayTunnelingProtocol = (typeof VpnGatewayTunnelingProtocol)[keyof typeof VpnGatewayTunnelingProtocol];
export declare const VpnType: {
    readonly PolicyBased: "PolicyBased";
    readonly RouteBased: "RouteBased";
};
/**
 * The type of this virtual network gateway.
 */
export declare type VpnType = (typeof VpnType)[keyof typeof VpnType];
export declare const WebApplicationFirewallAction: {
    readonly Allow: "Allow";
    readonly Block: "Block";
    readonly Log: "Log";
};
/**
 * Type of Actions.
 */
export declare type WebApplicationFirewallAction = (typeof WebApplicationFirewallAction)[keyof typeof WebApplicationFirewallAction];
export declare const WebApplicationFirewallEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if the policy is in enabled state or disabled state.
 */
export declare type WebApplicationFirewallEnabledState = (typeof WebApplicationFirewallEnabledState)[keyof typeof WebApplicationFirewallEnabledState];
export declare const WebApplicationFirewallMatchVariable: {
    readonly RemoteAddr: "RemoteAddr";
    readonly RequestMethod: "RequestMethod";
    readonly QueryString: "QueryString";
    readonly PostArgs: "PostArgs";
    readonly RequestUri: "RequestUri";
    readonly RequestHeaders: "RequestHeaders";
    readonly RequestBody: "RequestBody";
    readonly RequestCookies: "RequestCookies";
};
/**
 * Match Variable.
 */
export declare type WebApplicationFirewallMatchVariable = (typeof WebApplicationFirewallMatchVariable)[keyof typeof WebApplicationFirewallMatchVariable];
export declare const WebApplicationFirewallMode: {
    readonly Prevention: "Prevention";
    readonly Detection: "Detection";
};
/**
 * Describes if it is in detection mode or prevention mode at policy level.
 */
export declare type WebApplicationFirewallMode = (typeof WebApplicationFirewallMode)[keyof typeof WebApplicationFirewallMode];
export declare const WebApplicationFirewallOperator: {
    readonly IPMatch: "IPMatch";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly LessThan: "LessThan";
    readonly GreaterThan: "GreaterThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly Regex: "Regex";
};
/**
 * Describes operator to be matched.
 */
export declare type WebApplicationFirewallOperator = (typeof WebApplicationFirewallOperator)[keyof typeof WebApplicationFirewallOperator];
export declare const WebApplicationFirewallRuleType: {
    readonly MatchRule: "MatchRule";
    readonly Invalid: "Invalid";
};
/**
 * Describes type of rule.
 */
export declare type WebApplicationFirewallRuleType = (typeof WebApplicationFirewallRuleType)[keyof typeof WebApplicationFirewallRuleType];
export declare const WebApplicationFirewallTransform: {
    readonly Lowercase: "Lowercase";
    readonly Trim: "Trim";
    readonly UrlDecode: "UrlDecode";
    readonly UrlEncode: "UrlEncode";
    readonly RemoveNulls: "RemoveNulls";
    readonly HtmlEntityDecode: "HtmlEntityDecode";
};
/**
 * Describes what transforms applied before matching.
 */
export declare type WebApplicationFirewallTransform = (typeof WebApplicationFirewallTransform)[keyof typeof WebApplicationFirewallTransform];
