export declare const ActionType: {
    readonly Allow: "Allow";
    readonly Block: "Block";
    readonly Log: "Log";
    readonly Redirect: "Redirect";
};
/**
 * Describes what action to be applied when rule matches
 */
export declare type ActionType = (typeof ActionType)[keyof typeof ActionType];
export declare const CacheBehavior: {
    readonly BypassCache: "BypassCache";
    readonly Override: "Override";
    readonly SetIfMissing: "SetIfMissing";
};
/**
 * Caching behavior for the requests
 */
export declare type CacheBehavior = (typeof CacheBehavior)[keyof typeof CacheBehavior];
export declare const CacheType: {
    readonly All: "All";
};
/**
 * The level at which the content needs to be cached.
 */
export declare type CacheType = (typeof CacheType)[keyof typeof CacheType];
export declare const CookiesOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
};
/**
 * Describes operator to be matched
 */
export declare type CookiesOperator = (typeof CookiesOperator)[keyof typeof CookiesOperator];
export declare const CustomRuleEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
 */
export declare type CustomRuleEnabledState = (typeof CustomRuleEnabledState)[keyof typeof CustomRuleEnabledState];
export declare const DeliveryRuleAction: {
    readonly CacheExpiration: "CacheExpiration";
    readonly CacheKeyQueryString: "CacheKeyQueryString";
    readonly ModifyRequestHeader: "ModifyRequestHeader";
    readonly ModifyResponseHeader: "ModifyResponseHeader";
    readonly UrlRedirect: "UrlRedirect";
    readonly UrlRewrite: "UrlRewrite";
    readonly UrlSigning: "UrlSigning";
};
/**
 * The name of the action for the delivery rule.
 */
export declare type DeliveryRuleAction = (typeof DeliveryRuleAction)[keyof typeof DeliveryRuleAction];
export declare const DestinationProtocol: {
    readonly MatchRequest: "MatchRequest";
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Protocol to use for the redirect. The default value is MatchRequest
 */
export declare type DestinationProtocol = (typeof DestinationProtocol)[keyof typeof DestinationProtocol];
export declare const GeoFilterActions: {
    readonly Block: "Block";
    readonly Allow: "Allow";
};
/**
 * Action of the geo filter, i.e. allow or block access.
 */
export declare type GeoFilterActions = (typeof GeoFilterActions)[keyof typeof GeoFilterActions];
export declare const HeaderAction: {
    readonly Append: "Append";
    readonly Overwrite: "Overwrite";
    readonly Delete: "Delete";
};
/**
 * Action to perform
 */
export declare type HeaderAction = (typeof HeaderAction)[keyof typeof HeaderAction];
export declare const HealthProbeRequestType: {
    readonly NotSet: "NotSet";
    readonly GET: "GET";
    readonly HEAD: "HEAD";
};
/**
 * The type of health probe request that is made.
 */
export declare type HealthProbeRequestType = (typeof HealthProbeRequestType)[keyof typeof HealthProbeRequestType];
export declare const HttpVersionOperator: {
    readonly Equal: "Equal";
};
/**
 * Describes operator to be matched
 */
export declare type HttpVersionOperator = (typeof HttpVersionOperator)[keyof typeof HttpVersionOperator];
export declare const IsDeviceOperator: {
    readonly Equal: "Equal";
};
/**
 * Describes operator to be matched
 */
export declare type IsDeviceOperator = (typeof IsDeviceOperator)[keyof typeof IsDeviceOperator];
export declare const ManagedRuleEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
 */
export declare type ManagedRuleEnabledState = (typeof ManagedRuleEnabledState)[keyof typeof ManagedRuleEnabledState];
export declare const MatchVariable: {
    readonly RemoteAddr: "RemoteAddr";
    readonly SocketAddr: "SocketAddr";
    readonly RequestMethod: "RequestMethod";
    readonly RequestHeader: "RequestHeader";
    readonly RequestUri: "RequestUri";
    readonly QueryString: "QueryString";
    readonly RequestBody: "RequestBody";
    readonly Cookies: "Cookies";
    readonly PostArgs: "PostArgs";
};
/**
 * Match variable to compare against.
 */
export declare type MatchVariable = (typeof MatchVariable)[keyof typeof MatchVariable];
export declare const Operator: {
    readonly Any: "Any";
    readonly IPMatch: "IPMatch";
    readonly GeoMatch: "GeoMatch";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly LessThan: "LessThan";
    readonly GreaterThan: "GreaterThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export declare type Operator = (typeof Operator)[keyof typeof Operator];
export declare const OptimizationType: {
    readonly GeneralWebDelivery: "GeneralWebDelivery";
    readonly GeneralMediaStreaming: "GeneralMediaStreaming";
    readonly VideoOnDemandMediaStreaming: "VideoOnDemandMediaStreaming";
    readonly LargeFileDownload: "LargeFileDownload";
    readonly DynamicSiteAcceleration: "DynamicSiteAcceleration";
};
/**
 * Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download, Media services. With this information, CDN can apply scenario driven optimization.
 */
export declare type OptimizationType = (typeof OptimizationType)[keyof typeof OptimizationType];
export declare const PolicyEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * describes if the policy is in enabled state or disabled state
 */
export declare type PolicyEnabledState = (typeof PolicyEnabledState)[keyof typeof PolicyEnabledState];
export declare const PolicyMode: {
    readonly Prevention: "Prevention";
    readonly Detection: "Detection";
};
/**
 * Describes if it is in detection mode or prevention mode at policy level.
 */
export declare type PolicyMode = (typeof PolicyMode)[keyof typeof PolicyMode];
export declare const PostArgsOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
};
/**
 * Describes operator to be matched
 */
export declare type PostArgsOperator = (typeof PostArgsOperator)[keyof typeof PostArgsOperator];
export declare const ProbeProtocol: {
    readonly NotSet: "NotSet";
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Protocol to use for health probe.
 */
export declare type ProbeProtocol = (typeof ProbeProtocol)[keyof typeof ProbeProtocol];
export declare const QueryStringBehavior: {
    readonly Include: "Include";
    readonly IncludeAll: "IncludeAll";
    readonly Exclude: "Exclude";
    readonly ExcludeAll: "ExcludeAll";
};
/**
 * Caching behavior for the requests
 */
export declare type QueryStringBehavior = (typeof QueryStringBehavior)[keyof typeof QueryStringBehavior];
export declare const QueryStringCachingBehavior: {
    readonly IgnoreQueryString: "IgnoreQueryString";
    readonly BypassCaching: "BypassCaching";
    readonly UseQueryString: "UseQueryString";
    readonly NotSet: "NotSet";
};
/**
 * Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.
 */
export declare type QueryStringCachingBehavior = (typeof QueryStringCachingBehavior)[keyof typeof QueryStringCachingBehavior];
export declare const QueryStringOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
};
/**
 * Describes operator to be matched
 */
export declare type QueryStringOperator = (typeof QueryStringOperator)[keyof typeof QueryStringOperator];
export declare const RedirectType: {
    readonly Moved: "Moved";
    readonly Found: "Found";
    readonly TemporaryRedirect: "TemporaryRedirect";
    readonly PermanentRedirect: "PermanentRedirect";
};
/**
 * The redirect type the rule will use when redirecting traffic.
 */
export declare type RedirectType = (typeof RedirectType)[keyof typeof RedirectType];
export declare const RemoteAddressOperator: {
    readonly Any: "Any";
    readonly IPMatch: "IPMatch";
    readonly GeoMatch: "GeoMatch";
};
/**
 * Describes operator to be matched
 */
export declare type RemoteAddressOperator = (typeof RemoteAddressOperator)[keyof typeof RemoteAddressOperator];
export declare const RequestBodyOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
};
/**
 * Describes operator to be matched
 */
export declare type RequestBodyOperator = (typeof RequestBodyOperator)[keyof typeof RequestBodyOperator];
export declare const RequestHeaderOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
};
/**
 * Describes operator to be matched
 */
export declare type RequestHeaderOperator = (typeof RequestHeaderOperator)[keyof typeof RequestHeaderOperator];
export declare const RequestMethodOperator: {
    readonly Equal: "Equal";
};
/**
 * Describes operator to be matched
 */
export declare type RequestMethodOperator = (typeof RequestMethodOperator)[keyof typeof RequestMethodOperator];
export declare const RequestUriOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
};
/**
 * Describes operator to be matched
 */
export declare type RequestUriOperator = (typeof RequestUriOperator)[keyof typeof RequestUriOperator];
export declare const ResponseBasedDetectedErrorTypes: {
    readonly None: "None";
    readonly TcpErrorsOnly: "TcpErrorsOnly";
    readonly TcpAndHttpErrors: "TcpAndHttpErrors";
};
/**
 * Type of response errors for real user requests for which origin will be deemed unhealthy
 */
export declare type ResponseBasedDetectedErrorTypes = (typeof ResponseBasedDetectedErrorTypes)[keyof typeof ResponseBasedDetectedErrorTypes];
export declare const SkuName: {
    readonly Standard_Verizon: "Standard_Verizon";
    readonly Premium_Verizon: "Premium_Verizon";
    readonly Custom_Verizon: "Custom_Verizon";
    readonly Standard_Akamai: "Standard_Akamai";
    readonly Standard_ChinaCdn: "Standard_ChinaCdn";
    readonly Standard_Microsoft: "Standard_Microsoft";
    readonly Premium_ChinaCdn: "Premium_ChinaCdn";
};
/**
 * Name of the pricing tier.
 */
export declare type SkuName = (typeof SkuName)[keyof typeof SkuName];
export declare const Transform: {
    readonly Lowercase: "Lowercase";
    readonly Uppercase: "Uppercase";
};
/**
 * Describes what transforms are applied before matching
 */
export declare type Transform = (typeof Transform)[keyof typeof Transform];
export declare const TransformType: {
    readonly Lowercase: "Lowercase";
    readonly Uppercase: "Uppercase";
    readonly Trim: "Trim";
    readonly UrlDecode: "UrlDecode";
    readonly UrlEncode: "UrlEncode";
    readonly RemoveNulls: "RemoveNulls";
};
/**
 * Describes what transforms were applied before matching.
 */
export declare type TransformType = (typeof TransformType)[keyof typeof TransformType];
export declare const UrlFileExtensionOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
};
/**
 * Describes operator to be matched
 */
export declare type UrlFileExtensionOperator = (typeof UrlFileExtensionOperator)[keyof typeof UrlFileExtensionOperator];
export declare const UrlFileNameOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
};
/**
 * Describes operator to be matched
 */
export declare type UrlFileNameOperator = (typeof UrlFileNameOperator)[keyof typeof UrlFileNameOperator];
export declare const UrlPathOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly Wildcard: "Wildcard";
};
/**
 * Describes operator to be matched
 */
export declare type UrlPathOperator = (typeof UrlPathOperator)[keyof typeof UrlPathOperator];
