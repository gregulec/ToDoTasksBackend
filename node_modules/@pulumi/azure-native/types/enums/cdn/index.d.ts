import * as v20150601 from "./v20150601";
import * as v20160402 from "./v20160402";
import * as v20161002 from "./v20161002";
import * as v20170402 from "./v20170402";
import * as v20171012 from "./v20171012";
import * as v20190415 from "./v20190415";
import * as v20190615 from "./v20190615";
import * as v20190615preview from "./v20190615preview";
import * as v20191231 from "./v20191231";
import * as v20200331 from "./v20200331";
import * as v20200415 from "./v20200415";
import * as v20200901 from "./v20200901";
export { v20150601, v20160402, v20161002, v20170402, v20171012, v20190415, v20190615, v20190615preview, v20191231, v20200331, v20200415, v20200901, };
export declare const AFDEndpointProtocols: {
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Supported protocols for the customer's endpoint.
 */
export declare type AFDEndpointProtocols = (typeof AFDEndpointProtocols)[keyof typeof AFDEndpointProtocols];
export declare const ActionType: {
    readonly Allow: "Allow";
    readonly Block: "Block";
    readonly Log: "Log";
    readonly Redirect: "Redirect";
};
/**
 * Describes what action to be applied when rule matches
 */
export declare type ActionType = (typeof ActionType)[keyof typeof ActionType];
export declare const AfdCertificateType: {
    readonly CustomerCertificate: "CustomerCertificate";
    readonly ManagedCertificate: "ManagedCertificate";
};
/**
 * Defines the source of the SSL certificate.
 */
export declare type AfdCertificateType = (typeof AfdCertificateType)[keyof typeof AfdCertificateType];
export declare const AfdMinimumTlsVersion: {
    readonly TLS10: "TLS10";
    readonly TLS12: "TLS12";
};
/**
 * TLS protocol version that will be used for Https
 */
export declare type AfdMinimumTlsVersion = (typeof AfdMinimumTlsVersion)[keyof typeof AfdMinimumTlsVersion];
export declare const AfdQueryStringCachingBehavior: {
    readonly IgnoreQueryString: "IgnoreQueryString";
    readonly UseQueryString: "UseQueryString";
    readonly NotSet: "NotSet";
};
/**
 * Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.
 */
export declare type AfdQueryStringCachingBehavior = (typeof AfdQueryStringCachingBehavior)[keyof typeof AfdQueryStringCachingBehavior];
export declare const Algorithm: {
    readonly SHA256: "SHA256";
};
/**
 * Algorithm to use for URL signing
 */
export declare type Algorithm = (typeof Algorithm)[keyof typeof Algorithm];
export declare const CacheBehavior: {
    readonly BypassCache: "BypassCache";
    readonly Override: "Override";
    readonly SetIfMissing: "SetIfMissing";
};
/**
 * Caching behavior for the requests
 */
export declare type CacheBehavior = (typeof CacheBehavior)[keyof typeof CacheBehavior];
export declare const CacheType: {
    readonly All: "All";
};
/**
 * The level at which the content needs to be cached.
 */
export declare type CacheType = (typeof CacheType)[keyof typeof CacheType];
export declare const CookiesOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export declare type CookiesOperator = (typeof CookiesOperator)[keyof typeof CookiesOperator];
export declare const CustomRuleEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
 */
export declare type CustomRuleEnabledState = (typeof CustomRuleEnabledState)[keyof typeof CustomRuleEnabledState];
export declare const DeliveryRuleAction: {
    readonly CacheExpiration: "CacheExpiration";
    readonly CacheKeyQueryString: "CacheKeyQueryString";
    readonly ModifyRequestHeader: "ModifyRequestHeader";
    readonly ModifyResponseHeader: "ModifyResponseHeader";
    readonly UrlRedirect: "UrlRedirect";
    readonly UrlRewrite: "UrlRewrite";
    readonly UrlSigning: "UrlSigning";
    readonly OriginGroupOverride: "OriginGroupOverride";
};
/**
 * The name of the action for the delivery rule.
 */
export declare type DeliveryRuleAction = (typeof DeliveryRuleAction)[keyof typeof DeliveryRuleAction];
export declare const DestinationProtocol: {
    readonly MatchRequest: "MatchRequest";
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Protocol to use for the redirect. The default value is MatchRequest
 */
export declare type DestinationProtocol = (typeof DestinationProtocol)[keyof typeof DestinationProtocol];
export declare const EnabledState: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
 */
export declare type EnabledState = (typeof EnabledState)[keyof typeof EnabledState];
export declare const ForwardingProtocol: {
    readonly HttpOnly: "HttpOnly";
    readonly HttpsOnly: "HttpsOnly";
    readonly MatchRequest: "MatchRequest";
};
/**
 * Protocol this rule will use when forwarding traffic to backends.
 */
export declare type ForwardingProtocol = (typeof ForwardingProtocol)[keyof typeof ForwardingProtocol];
export declare const GeoFilterActions: {
    readonly Block: "Block";
    readonly Allow: "Allow";
};
/**
 * Action of the geo filter, i.e. allow or block access.
 */
export declare type GeoFilterActions = (typeof GeoFilterActions)[keyof typeof GeoFilterActions];
export declare const HeaderAction: {
    readonly Append: "Append";
    readonly Overwrite: "Overwrite";
    readonly Delete: "Delete";
};
/**
 * Action to perform
 */
export declare type HeaderAction = (typeof HeaderAction)[keyof typeof HeaderAction];
export declare const HealthProbeRequestType: {
    readonly NotSet: "NotSet";
    readonly GET: "GET";
    readonly HEAD: "HEAD";
};
/**
 * The type of health probe request that is made.
 */
export declare type HealthProbeRequestType = (typeof HealthProbeRequestType)[keyof typeof HealthProbeRequestType];
export declare const HttpVersionOperator: {
    readonly Equal: "Equal";
};
/**
 * Describes operator to be matched
 */
export declare type HttpVersionOperator = (typeof HttpVersionOperator)[keyof typeof HttpVersionOperator];
export declare const HttpsRedirect: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * Whether to automatically redirect HTTP traffic to HTTPS traffic. Note that this is a easy way to set up this rule and it will be the first rule that gets executed.
 */
export declare type HttpsRedirect = (typeof HttpsRedirect)[keyof typeof HttpsRedirect];
export declare const IsDeviceOperator: {
    readonly Equal: "Equal";
};
/**
 * Describes operator to be matched
 */
export declare type IsDeviceOperator = (typeof IsDeviceOperator)[keyof typeof IsDeviceOperator];
export declare const LinkToDefaultDomain: {
    readonly Enabled: "Enabled";
    readonly Disabled: "Disabled";
};
/**
 * whether this route will be linked to the default endpoint domain.
 */
export declare type LinkToDefaultDomain = (typeof LinkToDefaultDomain)[keyof typeof LinkToDefaultDomain];
export declare const ManagedRuleEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
 */
export declare type ManagedRuleEnabledState = (typeof ManagedRuleEnabledState)[keyof typeof ManagedRuleEnabledState];
export declare const MatchProcessingBehavior: {
    readonly Continue: "Continue";
    readonly Stop: "Stop";
};
/**
 * If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
 */
export declare type MatchProcessingBehavior = (typeof MatchProcessingBehavior)[keyof typeof MatchProcessingBehavior];
export declare const MatchVariable: {
    readonly RemoteAddress: "RemoteAddress";
    readonly RequestMethod: "RequestMethod";
    readonly QueryString: "QueryString";
    readonly PostArgs: "PostArgs";
    readonly RequestUri: "RequestUri";
    readonly RequestHeader: "RequestHeader";
    readonly RequestBody: "RequestBody";
    readonly RequestScheme: "RequestScheme";
    readonly UrlPath: "UrlPath";
    readonly UrlFileExtension: "UrlFileExtension";
    readonly UrlFileName: "UrlFileName";
    readonly HttpVersion: "HttpVersion";
    readonly Cookies: "Cookies";
    readonly IsDevice: "IsDevice";
};
/**
 * The name of the condition for the delivery rule.
 */
export declare type MatchVariable = (typeof MatchVariable)[keyof typeof MatchVariable];
export declare const Operator: {
    readonly Any: "Any";
    readonly IPMatch: "IPMatch";
    readonly GeoMatch: "GeoMatch";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly LessThan: "LessThan";
    readonly GreaterThan: "GreaterThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export declare type Operator = (typeof Operator)[keyof typeof Operator];
export declare const OptimizationType: {
    readonly GeneralWebDelivery: "GeneralWebDelivery";
    readonly GeneralMediaStreaming: "GeneralMediaStreaming";
    readonly VideoOnDemandMediaStreaming: "VideoOnDemandMediaStreaming";
    readonly LargeFileDownload: "LargeFileDownload";
    readonly DynamicSiteAcceleration: "DynamicSiteAcceleration";
};
/**
 * Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download, Media services. With this information, CDN can apply scenario driven optimization.
 */
export declare type OptimizationType = (typeof OptimizationType)[keyof typeof OptimizationType];
export declare const ParamIndicator: {
    readonly Expires: "Expires";
    readonly KeyId: "KeyId";
    readonly Signature: "Signature";
};
/**
 * Indicates the purpose of the parameter
 */
export declare type ParamIndicator = (typeof ParamIndicator)[keyof typeof ParamIndicator];
export declare const PolicyEnabledState: {
    readonly Disabled: "Disabled";
    readonly Enabled: "Enabled";
};
/**
 * describes if the policy is in enabled state or disabled state
 */
export declare type PolicyEnabledState = (typeof PolicyEnabledState)[keyof typeof PolicyEnabledState];
export declare const PolicyMode: {
    readonly Prevention: "Prevention";
    readonly Detection: "Detection";
};
/**
 * Describes if it is in detection mode or prevention mode at policy level.
 */
export declare type PolicyMode = (typeof PolicyMode)[keyof typeof PolicyMode];
export declare const PostArgsOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export declare type PostArgsOperator = (typeof PostArgsOperator)[keyof typeof PostArgsOperator];
export declare const ProbeProtocol: {
    readonly NotSet: "NotSet";
    readonly Http: "Http";
    readonly Https: "Https";
};
/**
 * Protocol to use for health probe.
 */
export declare type ProbeProtocol = (typeof ProbeProtocol)[keyof typeof ProbeProtocol];
export declare const QueryStringBehavior: {
    readonly Include: "Include";
    readonly IncludeAll: "IncludeAll";
    readonly Exclude: "Exclude";
    readonly ExcludeAll: "ExcludeAll";
};
/**
 * Caching behavior for the requests
 */
export declare type QueryStringBehavior = (typeof QueryStringBehavior)[keyof typeof QueryStringBehavior];
export declare const QueryStringCachingBehavior: {
    readonly IgnoreQueryString: "IgnoreQueryString";
    readonly BypassCaching: "BypassCaching";
    readonly UseQueryString: "UseQueryString";
    readonly NotSet: "NotSet";
};
/**
 * Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.
 */
export declare type QueryStringCachingBehavior = (typeof QueryStringCachingBehavior)[keyof typeof QueryStringCachingBehavior];
export declare const QueryStringOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export declare type QueryStringOperator = (typeof QueryStringOperator)[keyof typeof QueryStringOperator];
export declare const RedirectType: {
    readonly Moved: "Moved";
    readonly Found: "Found";
    readonly TemporaryRedirect: "TemporaryRedirect";
    readonly PermanentRedirect: "PermanentRedirect";
};
/**
 * The redirect type the rule will use when redirecting traffic.
 */
export declare type RedirectType = (typeof RedirectType)[keyof typeof RedirectType];
export declare const RemoteAddressOperator: {
    readonly Any: "Any";
    readonly IPMatch: "IPMatch";
    readonly GeoMatch: "GeoMatch";
};
/**
 * Describes operator to be matched
 */
export declare type RemoteAddressOperator = (typeof RemoteAddressOperator)[keyof typeof RemoteAddressOperator];
export declare const RequestBodyOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export declare type RequestBodyOperator = (typeof RequestBodyOperator)[keyof typeof RequestBodyOperator];
export declare const RequestHeaderOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export declare type RequestHeaderOperator = (typeof RequestHeaderOperator)[keyof typeof RequestHeaderOperator];
export declare const RequestMethodOperator: {
    readonly Equal: "Equal";
};
/**
 * Describes operator to be matched
 */
export declare type RequestMethodOperator = (typeof RequestMethodOperator)[keyof typeof RequestMethodOperator];
export declare const RequestUriOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export declare type RequestUriOperator = (typeof RequestUriOperator)[keyof typeof RequestUriOperator];
export declare const ResponseBasedDetectedErrorTypes: {
    readonly None: "None";
    readonly TcpErrorsOnly: "TcpErrorsOnly";
    readonly TcpAndHttpErrors: "TcpAndHttpErrors";
};
/**
 * Type of response errors for real user requests for which origin will be deemed unhealthy
 */
export declare type ResponseBasedDetectedErrorTypes = (typeof ResponseBasedDetectedErrorTypes)[keyof typeof ResponseBasedDetectedErrorTypes];
export declare const SecretType: {
    readonly UrlSigningKey: "UrlSigningKey";
    readonly CustomerCertificate: "CustomerCertificate";
    readonly ManagedCertificate: "ManagedCertificate";
};
/**
 * The type of the Secret to create.
 */
export declare type SecretType = (typeof SecretType)[keyof typeof SecretType];
export declare const SecurityPolicyType: {
    readonly WebApplicationFirewall: "WebApplicationFirewall";
};
/**
 * The type of the Security policy to create.
 */
export declare type SecurityPolicyType = (typeof SecurityPolicyType)[keyof typeof SecurityPolicyType];
export declare const SharedPrivateLinkResourceStatus: {
    readonly Pending: "Pending";
    readonly Approved: "Approved";
    readonly Rejected: "Rejected";
    readonly Disconnected: "Disconnected";
    readonly Timeout: "Timeout";
};
/**
 * Status of the shared private link resource. Can be Pending, Approved, Rejected, Disconnected, or Timeout.
 */
export declare type SharedPrivateLinkResourceStatus = (typeof SharedPrivateLinkResourceStatus)[keyof typeof SharedPrivateLinkResourceStatus];
export declare const SkuName: {
    readonly Standard_Verizon: "Standard_Verizon";
    readonly Premium_Verizon: "Premium_Verizon";
    readonly Custom_Verizon: "Custom_Verizon";
    readonly Standard_Akamai: "Standard_Akamai";
    readonly Standard_ChinaCdn: "Standard_ChinaCdn";
    readonly Standard_Microsoft: "Standard_Microsoft";
    readonly Premium_ChinaCdn: "Premium_ChinaCdn";
    readonly Standard_AzureFrontDoor: "Standard_AzureFrontDoor";
    readonly Premium_AzureFrontDoor: "Premium_AzureFrontDoor";
    readonly Standard_955BandWidth_ChinaCdn: "Standard_955BandWidth_ChinaCdn";
    readonly Standard_AvgBandWidth_ChinaCdn: "Standard_AvgBandWidth_ChinaCdn";
    readonly StandardPlus_ChinaCdn: "StandardPlus_ChinaCdn";
    readonly StandardPlus_955BandWidth_ChinaCdn: "StandardPlus_955BandWidth_ChinaCdn";
    readonly StandardPlus_AvgBandWidth_ChinaCdn: "StandardPlus_AvgBandWidth_ChinaCdn";
};
/**
 * Name of the pricing tier.
 */
export declare type SkuName = (typeof SkuName)[keyof typeof SkuName];
export declare const Transform: {
    readonly Lowercase: "Lowercase";
    readonly Uppercase: "Uppercase";
};
/**
 * Describes what transforms are applied before matching
 */
export declare type Transform = (typeof Transform)[keyof typeof Transform];
export declare const TransformType: {
    readonly Lowercase: "Lowercase";
    readonly Uppercase: "Uppercase";
    readonly Trim: "Trim";
    readonly UrlDecode: "UrlDecode";
    readonly UrlEncode: "UrlEncode";
    readonly RemoveNulls: "RemoveNulls";
};
/**
 * Describes what transforms were applied before matching.
 */
export declare type TransformType = (typeof TransformType)[keyof typeof TransformType];
export declare const UrlFileExtensionOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export declare type UrlFileExtensionOperator = (typeof UrlFileExtensionOperator)[keyof typeof UrlFileExtensionOperator];
export declare const UrlFileNameOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export declare type UrlFileNameOperator = (typeof UrlFileNameOperator)[keyof typeof UrlFileNameOperator];
export declare const UrlPathOperator: {
    readonly Any: "Any";
    readonly Equal: "Equal";
    readonly Contains: "Contains";
    readonly BeginsWith: "BeginsWith";
    readonly EndsWith: "EndsWith";
    readonly LessThan: "LessThan";
    readonly LessThanOrEqual: "LessThanOrEqual";
    readonly GreaterThan: "GreaterThan";
    readonly GreaterThanOrEqual: "GreaterThanOrEqual";
    readonly Wildcard: "Wildcard";
    readonly RegEx: "RegEx";
};
/**
 * Describes operator to be matched
 */
export declare type UrlPathOperator = (typeof UrlPathOperator)[keyof typeof UrlPathOperator];
